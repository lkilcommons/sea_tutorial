{
  "name": "Superposed Epoch Analysis Tutoral",
  "tagline": "SEA Tutorial For MATLAB",
  "body": "# Superposed Epoch Analysis in MATLAB\r\n\r\n![An example I created of a superposed epoch analysis of the Disturbance Storm Time index](dst1hrdst1hrepoch.png)\r\n> In this superposed epoch plot, I am showing the response of the Disturbance Storm Time index to Coronal Mass Ejections (CMEs) hitting\r\n> the earth's magnetic field. The DST measures the strength of the ring current, and is a proxy for the overall geomagnetic activity.\r\n> The green lines each represent an individual storm, and the red, black, and blue lines are the statistical response\r\n\r\n## What is superposed epoch analysis?\r\nSuperposed epoch analysis, also called _compositing_, \r\nis a technique for analyzing data that consists of measurements of the state of some observable system over time, \r\ni.e. a _timeseries_. More specifically, timeseries data in which some type of event repeatedly reoccurs.\r\n\r\n## An example\r\nFor a simple example from space science, we can consider the eleven year solar cycle, as measured by the sunspot number:\r\n![Image of the solar cycle](http://spaceweather.com/glossary/images2009/zurich_strip.gif)\r\n\r\nWhile the activity of the sun waxes and wanes every eleven years, there are stronger and weaker cycles. \r\nLet's say that we want to develop a simple model the average sunspot number and the range \r\nwe would expect for any given point in future solar cycles. This is a perfect use case for the superposed epoch analysis.\r\n\r\n## Step zero: get ready\r\nThe first tasks in any superposed epoch analysis are to obtain and import your timeseries data.\r\nWithout data, there is no analysis!\r\n\r\nI got the data here:\r\n[Sunspot number data as a CSV (comma separated variable) file](http://www.sidc.be/silso/INFO/sndtotcsv.php)\r\nBut it comes as part of the git repository.\r\n\r\nNow we must import the data into MATLAB. If you want to follow along, replace the path to the \r\ndata (`/home/liamk/mirror/Projects/superposedepoch_tutorial/`) with where you cloned or unzipped the git repository\r\non your computer.\r\n\r\n```{matlab}\r\nsunspot_data = importdata('/home/liamk/mirror/Projects/superposedepoch_tutorial/SN_d_tot_V2.0.csv');\r\n```\r\nWe will need to understand what is in our data.\r\n\r\nFrom SIDC website:\r\n> Contents:  \r\n> Column 1: Year   \r\n> Column 2: Month  \r\n> Column 3: Day  \r\n> Column 4: Date in fraction of year.  \r\n> Column 5: Daily total sunspot number. A value of -1 indicates that no number is available for that day (missing value).  \r\n> Column 6: Daily standard deviation of the input sunspot numbers from individual stations.  \r\n> Column 7: Number of observations used to compute the daily value.  \r\n> Column 8: Definitive/provisional indicator. '1' indicates that the value is definitive. '0' indicates that the value is still provisional.  \r\n\r\nIt's usually easier to work with time as a single, monotonically increasing number, rather than having to think about\r\nhow many days are in each month, etc,etc, so it's nice that the data provides us with column 4: \"date in fraction of year\".\r\nLet's define that as our time variable, and then use the data from column 5 for our analysis.\r\n\r\n```{matlab}\r\ntime = sunspot_data(:,4);\r\nssn = sunspot_data(:,5);\r\n```\r\n\r\nNext we should take care of those pesky missing values. If you leave them in there, they can really mess things up. \r\nWe'll just cut them out of the data entirely.\r\n\r\n```{matlab}\r\nmissing = ssn == -1;\r\ntime = time(~missing);\r\nssn = ssn(~missing);\r\n```\r\n\r\nNow we can really begin.\r\n\r\n## Step 1: Identify the events\r\n\r\nSuperposed epoch analysis (SEA) is all about _events_, which we can define as re-occurrences of some type of cyclical or episodic process.\r\nBasically, SEA is appropriate for analyzing anything that happens which has a beginning, middle, and end,\r\nand plays out similarly over time each time it happens.\r\n\r\nExamples of cyclical processes from earth sciences include our solar cycle example, or temperatures at a particular\r\nweather station in Canada during the rise and fall of the El Nino. Episodic processes\r\ncould include hurricanes passing by a particular observation station in the Pacific ocean, or earthquakes from a particular fault,\r\nwhich are observed by a particular seismometer station, or coronal mass ejections hitting the earth's magnetosphere, as observed by ACE, \r\nthe upstream solar wind monitor spacecraft.\r\n\r\nIn order to identify specific events, we have to define a single time as the quantitative 'center' of the event, so we can\r\ntell the beginning of the event apart from the middle and end, and compare the beginnings of different events with eachother,\r\nas opposed to the beginning of one event with the end of another, etc. In this way we can get a picture of how the process\r\nplays out over time for a 'typical' event.\r\n\r\nOur events will be individual solar cycles. We will use the maximum sunspot number for each solar cycle as our center time (sometimes called the zero epoch time)\r\n\r\nI'll give the code for the center times, but I looked them up for the nearest month on [wikipedia](https://en.wikipedia.org/wiki/List_of_solar_cycles)\r\n\r\n```{matlab}\r\nsolar_cycle_max_times = [1829+11/12,1837+3/12,1848+2/12,1860+2/12,1870+8/12,1883+12/12,...\r\n1894+1/12,1906+2/12,1917+8/12,1928+4/12,1937+4/12,1947+5/12,...\r\n1958+3/12,1958+3/12,1968+11/12,1979+12/12,1989+7/12,2000+3/12,2014+4/12];\r\n\r\n%Since we don't know if the actual max was nearer the beginning or the end of the month,\r\n%subtract half a month to put the center time in the middle of the specified month\r\nsolar_cycle_max_times = solar_cycle_max_times-1/24;\r\n```\r\nNote that these are in fractions of the year, the same as our sunspot observation times. Convenient!\r\n\r\nSince we want to analyze the response of a typical event, we need to pick an amount of time before and after the\r\nzero epoch time in which we think we will see something interesting. Since the shortest solar cycle on our list\r\nis about 9 years, it should be safe to do +- 4 years around our zero epoch time.\r\n\r\n```{matlab}\r\n%Loop through each solar cycle, or 'event'\r\nfor m = 1:length(solar_cycle_max_times)\r\n  this_solar_cycle_max_time = solar_cycle_max_times(m);\r\n  this_solar_cycle_times = time > this_solar_cycle_max_time-4 & time < this_solar_cycle_max_time+4;\r\n  %More code goes here later\r\nend\r\n```\r\n\r\n## Step 2: Bin the data into time bins relative to the zero epoch time\r\n\r\nIf we want to know what the sunspot number 1 year before the maximum is on average, and how that differs from 2 years before,\r\nwe need to divide each event into discrete time bins, so that the times for event 1 line up with exactly with the times for\r\nevent 2, etc. This makes the rest of the process a lot easier because the results can be stored in \r\na [number of events x number of time bins] matrix\r\n\r\n```{matlab}\r\nn_days_per_bin = 30; %Approx month long bins\r\nnbins = floor(365.25*8/n_days_per_bin);\r\ntime_bin_edges = linspace(-4,4,nbins+1);\r\n\r\nn_solar_cycles = length(solar_cycle_max_times);\r\n\r\n%Preallocate an array in which we will store our final results\r\n%each row will represent a solar cycle, each column, a time bin\r\nssn_by_event = zeros(n_solar_cycles,nbins);\r\n\r\n%Loop through events, and bin sunspot number data into time bins, and assign into\r\n%the results array\r\n\r\nfor m = 1:n_solar_cycles\r\n  this_solar_cycle_max_time = solar_cycle_max_times(m); \r\n  \r\n  %Create variables for sunspot number observations for just this solar cycle, with 0 epoch time being\r\n  %the sunspot maximum\r\n  this_solar_cycle_times = time > this_solar_cycle_max_time-4 & time < this_solar_cycle_max_time+4;\r\n  this_epoch_time = time(this_solar_cycle_times)-this_solar_cycle_max_time;\r\n  this_ssn = ssn(this_solar_cycle_times);\r\n  \r\n  for t = 1:nbins-1\r\n    in_bin_t = this_epoch_time >= time_bin_edges(t) & this_epoch_time < time_bin_edges(t+1);\r\n    ssn_by_event(m,t) = mean(this_ssn(in_bin_t));\r\n  end\r\n  \r\nend\r\n```\r\n\r\n## Step 3: Compute statistics about the data in each time bin\r\n\r\nNow that we have the data all nicely arranged in a matrix `ssn_by_event`, where \r\neach row represents one of the solar cycles, and each column one of the time bins,\r\nwe can use matlab's median and quantile functions to get the average sunspot number\r\nacross all of the solar cycles for each time bin.\r\n\r\n```{matlab}\r\n%Take the median of each column, to represent the average response for that\r\n%time bin, also take the 25th and 75th percentiles of each column, to\r\n%represent the spread in sunspot numbers for that time bin\r\ntime_bin_centers = (time_bin_edges(1:end-1)+time_bin_edges(2:end))/2;\r\naverage_ssn = nanmedian(ssn_by_event,1); %The 1 means to take the median for each column, not each row\r\nfirst_quartile_ssn = quantile(ssn_by_event,.25,1);\r\nthird_quartile_ssn = quantile(ssn_by_event,.75,1);\r\n```\r\n\r\n## Step 4: Plot your results and figure out what they are telling you\r\n\r\n```{matlab}\r\n%Plot the results\r\nf = figure();\r\na = axes(); hold(a,'on');\r\nplot(a,time_bin_centers,average_ssn,'b-');\r\nplot(a,time_bin_centers,first_quartile_ssn,'r--');\r\nplot(a,time_bin_centers,third_quartile_ssn,'r--');\r\nxlabel('Years since maximum sunspot number');\r\nylabel('International Sunspot Number');\r\ntitle(sprintf('Superposed Epoch Analysis of %d Solar Cycles (%d-%d)',n_solar_cycles,...\r\n    floor(time(1)),floor(time(end))));\r\nprint(f,'-dpng','sunspot_number_sea.png');\r\n```\r\n![Sunspot number solar cycle superposed epoch results](sunspot_number_sea.png)\r\n\r\nHere we can see the results! The interpretation is an exercise for the reader, for now ;)\r\n\r\n## Appendix: An alternate technique without time binning\r\n\r\nMany people will skip the time binning step and just try to line up the data for each \r\nevent by depending on the fact that the data comes in on a regular cadence (in the case of our sunspot data, \r\nthis is one value for each day). In this case, you can simply define each event as +- 1461\r\nvalues from the data array around the index of the value at the zero epoch time:\r\n\r\n```{matlab}\r\n%Loop through each solar cycle, or 'event'\r\nfor m = 1:length(solar_cycle_max_times)\r\n  this_solar_cycle_max_time = solar_cycle_max_times(m);\r\n  \r\n  %Assumes that time is sorted in ascending order (usually true)\r\n  closest_ssn_index_to_max_time = find(time>this_solar_cycle_max_time,1); \r\n  \r\n  %4 years in days = 365.25*4=1461\r\n  ssns_in_this_event = ssn(closest_ssn_index_to_max_time-1461:closest_ssn_index_to_max_time+1461);\r\n  \r\n  %More code goes here later\r\nend\r\n```\r\n\r\nThis works fine, as long as there are no large chunks of missing data and you really can depend\r\non the fact that the n-th point in the data array is for day n, and the n+1-th point is for day n+1,\r\nor whatever is the appropriate time step for your dataset.\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}